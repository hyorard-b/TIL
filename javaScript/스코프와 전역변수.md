# 스코프

## 스코프란

모든 식별자는 참조될 수 있는 유효 범위가 있는데, 이를 스코프라 하고, 스코프는 식별자가 선언된 위치에 따라 달라진다.

```javascript
var thiago = 'world class';

function glass() {
  var thiago = 'useless';
  console.log(thiago);
}

console.log(thiago);
```

식별자를 참조할 때, 엔진은 어떤 식별자를 참조할 지 문맥에 따라 결정하는데, 이를 식별자 결정이라 한다. 스코프는 이 식별자 결정을 할 때 사용하는 규칙이다.

스코프가 없다면, 같은 식별자를 가진 변수는 충돌을 일으키므로, 프로그램 전체에서 하나만 사용할 수 있을 것이다. 따라서, 변수는 유일한 식별자와만 연결될 수 있을 것이다. 그러나, 이렇게 된다면 모든 프로그램에서 쓰는 식별자를 모두 다르게 만들어야 하는데, 이는 매우 번거로운 일이 된다.

따라서, 다른 스코프에서는 같은 식별자를 사용해도 충돌이나 간섭이 없게 하기 때문에 스코프는 **네임스페이스**이기도 하다.

---

## 스코프의 종류

- 전역

  코드의 가장 바깥 영역으로, 이 영역의 스코프는 전역 스코프가 되고, 전역 스코프에서 선언된 변수는 전역 변수가 된다.

- 지역

  함수 몸체 내부 영역으로, 이 영역의 스코프는 지역 스코프가 되고, 지역 스코프에서 선언된 변수는 지역 변수가 된다.

### 전역과 전역 스코프

전역에 변수를 선언하면 전역 변수가 된다고 하였는데, 이 전역 변수는 어디서든지 참조할 수 있게 된다.

---

### 지역과 지역 스코프

지역에서 선언된 지역 변수는 지역 스코프와 해당 지역의 하위 스코프에서만 참조할 수 있다. 만약 어떤 변수를 참조하는데, 상위 스코프와 식별자가 동일하다면, 상대적 하위 지역 스코프의 변수를 참조하게 된다. 이는 자바스크립트 엔진이 스코프 체인을 통해 참조할 변수를 검색했기 때문이다.

---

## 스코프 체인

프로그램이 실행되면 콜 스택에 전역 렉시컬 환경이 푸쉬되고, 함수가 호출될 때마다, 지역 렉시컬 환경이 푸쉬된다. 이렇게 렉시컬 환경들이 단방향으로 연결되어 있는 것을 스코프 체인이라고 하고, 식별자 검색을 할 때, 가장 하위 스코프부터 위쪽 순으로 하게 된다.

렉시컬 환경은 "코드가 어디서 실행되며 주변에 어떤 코드가 있는지"를 말한다. 이를 구현한 것이 실행 컨텍스트이며, 위의 렉시컬 환경은 모두 실행 컨텍스트로 구현한 것이다.

### 스코프 체인에 의한 변수 검색

상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다.

---

### 스코프 체인에 의한 함수 검색

함수도 결국 변수 식별자에 할당되기 때문에, 함수 스코프 체인은 변수 스코프 체인과 같다 할 수 있다. 그러나, 이는 `var` 키워드를 사용했을 때에만 해당한다.

---

## 함수 레벨 스코프

함수 레벨 스코프는 코드 블록이 아닌 함수의 코드 블록만을 지역 스코프로 인정하는 것을 말한다. 블록 레벨 스코프는 함수 코드 블록 뿐 아니라, 모든 코드 블록에 지역 스코프를 생성하는 것을 말한다.

`var` 키워드로 선언된 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정하지만, ES6에서 도입된 `let`, `const` 키워드는 블록 레벨 스코프를 지원한다.

---

## 렉시컬 스코프

```javascript
var x = 1;

function foo() {
  var x = 10;
  console.log(`foo -> ${x}`);
  bar();
}

function bar() {
  console.log(`bar -> ${x}`);
}

foo(); // foo -> 10
// bar -> 1
bar(); // bar -> 1
```

- 동적 스코프

  함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다.

- 렉시컬(정적) 스코프

  함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다.

자바스크립트는 렉시컬 스코프를 따르기 때문에, 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다. 즉, 함수의 상위 스코프는 언제나 자신이 정의된 스코프이다.

함수가 정의되어 평가된 객체는 정적으로 결정된 상위 스코프를 기억하고, 함수가 호출될 때마다 함수의 상위 스코프를 참조하게 된다.

---

# 전역 변수의 문제점

지역 변수의 생명 주기는 함수의 생명 주기와 일치한다. 변수의 생명 주기는 메모리 공간이 확보(allocate)된 시점부터 메모리 공간이 해제(release)되어 가용 메모리 풀(memory pool)에 반환되는 시점까지이기 때문이다.

호이스팅은 스코프를 단위로 동작한다. 따라서, 지역 스코프 내에서도 호이스팅이 발생한다. 이는 전역 변수와 같은 이름을 가지고 있는 지역 변수도 마찬가지이다.

```javascript
var x = 'global';

function foo() {
  console.log(x); // ①
  var x = 'local';
}

foo();
console.log(x); // global
```

## 전역 객체

전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이다. 전역 변수는 바로 전역 객체의 프로퍼티가 된다. 즉, var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.

---

## 전역 변수의 문제점

1. 암묵적 결합

   전역 변수는 코드 어디서나 참조할 수 있다. 이는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 **암묵적 결합(implicit coupling)**을 허용하는 것이다. 이는 예상치 못한 에러를 발생시킬 수 있고, 코드 가독성을 해친다.

2. 네임스페이스 오염

   ```html
   <script src="index.js"></script>
   <script src="login.js"></script>
   ```

   이처럼 js 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유하기 때문에, 동일한 식별자를 가지는 변수나 전역 함수가 같은 스코프 내에 존재하게 된다면 예상치 못한 결과가 나타날 수 있다.

3. 긴 생명 주기

   전역 변수는 프로그램이 종료될 때 같이 메모리에서 해제된다. 이는 프로그램이 시작할 때부터 끝날 때까지 메모리에 존재한다는 것을 의미하는데 이는 메모리의 낭비를 의미하며, 의도치 않은 동작이 일어날 가능성도 커진다.

4. 스코프 체인의 종점에 존재 (성능 저하)

   전역 변수를 참조할 때, 전역 변수는 스코프 체인 종점에 존재하기 때문에, 변수 검색을 할 때, 가장 마지막까지 검색하여야 된다는 것을 의미한다. 따라서 검색 속도가 가장 느리다.

---

## 전역 변수 문제점 해결 방식

1. 즉시 실행 함수

   지역 스코프에서 변수를 만들어, 전역 변수의 사용을 제한하는 방식이다.

2. 네임스페이스 객체

   객체를 만들어 전역 변수 대신, 객체의 프로퍼티를 사용하는 방법이다. 이 방식은 프로퍼티는 전역 변수가 아니지만, 객체 자체가 전역 변수가 된다는 단점이 있다.

3. 모듈 패턴

   즉시 실행 함수안에 사용할 변수를 선언 및 할당하고, 해당 변수를 컨트롤할 함수를 반환하면, 즉시 실행 함수의 지역 변수는 반환한 함수를 통해서만 접근할 수 있게 된다. 일반적으로 함수가 종료하면 함수가 생성한 스코프도 소멸한다. 따라서, 즉시 실행 함수가 끝나면 생성한 스코프가 소멸하여 해당 변수도 소멸할 것 같았다. 하지만 누군가가 스코프를 참조하고 있다면 스코프는 해제되지 않고 생존하게 된다. 따라서, 함수를 통해 변수를 조작하면 조작한 값이 계속 남아있게 된다.

   ```javascript
   var Counter = (function () {
     // private 변수
     var num = 0;

     // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
     return {
       increase() {
         return ++num;
       },
       decrease() {
         return --num;
       },
     };
   })();

   console.log(Counter.increase()); // 1
   console.log(Counter.increase()); // 2
   console.log(Counter.increase()); // 3
   ```

   즉시 실행 함수를 쓰지 않고, 함수 표현식으로 함수를 정의하고 할당하게 되면, 함수가 호출되면서 지역 변수가 계속 재할당되게 된다.

   ```javascript
   var Counter = function () {
     // private 변수
     var num = 0;

     // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
     return {
       increase() {
         return ++num;
       },
       decrease() {
         return --num;
       },
     };
   };

   console.log(Counter().increase()); // 1
   console.log(Counter().increase()); // 1
   console.log(Counter().increase()); // 1
   ```

4. ES6 모듈

```javascript

<script type="module" src="lib.mjs"></script>
<script type="module" src="app.mjs"></script>

```

`script` 태그에 `type="module"` 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로써 동작하기 때문에, 파일 자체의 독자적인 모듈 스코프를 제공하게 된다. 그러나 호환성이 좋지 않다.
