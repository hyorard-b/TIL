# 함수

## 함수란?

함수란 일련의 과정을 문으로 구현하고 코드 블록으로 감싼 하나의 실행 단위이다.

함수를 호출할 때 전달하는 값을 **인수(argument)**, 함수 내부에서 입력을 전달받는 변수를 **매개변수(parameter)**, 출력을 **반환값(return value)**라고 한다.

---

## 함수의 사용 이유

1. 코드의 재사용

   같은 코드를 중복해서 여러 번 작성하는 것이 아니라, 미리 정의해놓고 필요할 때마다 호출한다.

2. 유지보수 용이

   같은 코드를 중복해서 작성한다면, 해당 코드를 모두 수정하여야 하는 반면, 함수를 정의하면, 정의한 곳만 고치면 된다.

3. 코드 가독성 상승

   함수는 물론, 매개변수에도 식별자를 붙일 수 있기 때문에, 식별자를 통해 함수의 역할을 파악할 수 있게 된다.

---

## 함수 리터럴

원시값, 객체와 마찬가지로 함수 또한 함수 리터럴로 생성할 수 있다. 함수 리터럴은 다음과 같이 구성된다.

- `function` 키워드
- 함수 이름

  함수 이름도 식별자이기 때문에 식별자 네이밍 규칙을 준수해야 한다.

  함수 이름은 선택 사항으로, 식별자를 가진 함수를 기명 함수, 가지지 않은 함수를 익명/무기명 함수라고 한다.

  함수 이름은 **함수 몸체 내에서만 참조할 수 있는 식별자이다.**

- 매개변수 목록

  매개 변수의 이름도 식별자이기 때문에 식별자 네이밍 규칙을 준수해야 한다.

  인수의 순서대로 매개 변수에 할당되기 때문에, 매개 변수의 순서는 의미가 있는 순서이다.

- 함수 몸체

```javascript
var f = function add(x, y) {
  return x + y;
};
```

리터럴은 값을 생성하기 위한 표기법으로, **함수 리터럴 또한 평가되어 값을 생성하며, 이 값은 객체이다.** 즉 함수는 객체이다.

---

## 함수 정의

함수를 정의하는 방법은 다음 4가지와 같다.

- 함수 **선언문**

  ```javascript
  function trainAgility(player) {
    player.agility += 1;
  }
  ```

- 함수 표현식

  ```javascript
  var trainAgility = function (player) {
    player.agility += 1;
  };
  ```

- `Function` 생성자 함수

  ```javascript
  var trainAgility = new Function('player', 'player.agility += 1');
  ```

- 화살표 함수

  ```javascript
  var trainAgility = (player) => {
    player.agility += 1;
  };
  ```

함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다. 따라서 ECMAScript 사양에서도 변수는 선언한다고 표현하지만, 함수는 정의한다고 표현한다. 실제로 변수도 선언과 동시에 `undefined` 값이 할당되어 정의되지만, ECMAScript 사양을 따르자..!

---

### 함수 선언문

함수 선언문을 이용해 함수를 정의할 때에는 함수의 식별자(이름)을 생략할 수 없다. 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다. 그런데 왜 함수 선언문을 이용하여 함수를 정의할 때 함수의 식별자를 생략할 수 없는 것일까?

먼저, 함수 표현식과 함수 선언문의 차이부터 살펴보자. 함수 선언문은 함수 식별자를 생략할 수 없다. 함수 표현식에서 함수 식별자는 선택 사항이다. 따라서, 함수 식별자를 가지고 있는 함수 표현식은 함수 선언문과 똑같이 생겼다. 따라서 자바스크립트 엔진이 함수 식별자를 가진 함수 표현식을 함수 선언문으로 해석할 가능성이 생긴다.

그래서, 자바스크립트 엔진은 식별자를 가진 함수 리터럴이 단독으로 쓰이면 함수 선언문으로 판단하고, 식별자를 가진 함수 리터럴이 피연산자로 쓰이면 함수 표현식으로 해석한다. 함수를 정의하는 방식이 비슷해보이지만, 내부 동작은 다르다. 내부 동작의 차이에 대해 알아보자.

```javascript
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() {
  console.log('foo');
}
foo(); // foo

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
// 함수 리터럴에서는 함수 이름을 생략할 수 있다.
(function bar() {
  console.log('bar');
});
bar(); // ReferenceError: bar is not defined
```

먼저 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자이기 때문에, 함수 외부에서는 함수 이름으로 함수를 호출할 수 없다. 즉, 함수를 가리키는 식별자가 없다는 뜻이다. 따라서 위의 두 코드는 함수를 어떤 식별자에 함수를 할당하지 않았기 때문에, 두 코드 모두 원래 `ReferenceError`가 나야 정상이다. 둘 모두 함수 식별자로 호출하려 시도했지만, 메모리 공간 어디에도 함수 식별자가 가리키는 공간은 없기 때문이다.

그러나, 함수 선언문으로 정의한 함수 `foo`는 함수 식별자로 호출되었다. 이는 단독으로 쓰인 기명 함수 리터럴은 함수 선언문으로 가정하고,

1. 함수 선언문을 해석하여 함수 객체를 생성한다.

2. 생성된 함수를 호출하기 위해 함수 식별자와 동일한 이름의 식별자를 암묵적으로 생성한다.

3. 생성한 식별자에 생성된 함수 객체를 할당한다.

이러한 이유로 식별자를 가진 함수 리터럴을 단독으로 사용할 때( = 함수 선언문으로 함수를 정의할 때)에 식별자를 생략할 수 없다. **중요한 것은 함수 식별자로 함수를 호출한 것으로 보이지만, 사실은 함수 객체를 가리키는 식별자로 호출한 것이다.**

반대로, 두 번째 코드는 기명 함수 리터럴이 그룹 연산자 `()`의 피연산자로 쓰여 자바스크립트 엔진이 함수 표현식으로 판단하였고, 함수 선언문과 달리 함수 식별자와 동일한 이름의 식별자를 암묵적으로 생성하지 않았기 때문에 함수 식별자로 호출하려 시도하였지만, 호출이 되지 않은 것이다.

---

### 함수 표현식

일급 객체란 값으로 사용할 수 있는 객체를 말한다. 함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이렇게 정의하는 방식을 함수 표현식이라 한다.

위에서 설명했듯이 함수 선언문과 함수 표현식은 비슷하게 동작하는 것처럼 보이지만 내부 동작이 매우 다르다..!
