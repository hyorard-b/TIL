# 함수

## 함수란?

함수란 일련의 과정을 문으로 구현하고 코드 블록으로 감싼 하나의 실행 단위이다.

함수를 호출할 때 전달하는 값을 **인수(argument)**, 함수 내부에서 입력을 전달받는 변수를 **매개변수(parameter)**, 출력을 **반환값(return value)**라고 한다.

---

## 함수의 사용 이유

1. 코드의 재사용

   같은 코드를 중복해서 여러 번 작성하는 것이 아니라, 미리 정의해놓고 필요할 때마다 호출한다.

2. 유지보수 용이

   같은 코드를 중복해서 작성한다면, 해당 코드를 모두 수정하여야 하는 반면, 함수를 정의하면, 정의한 곳만 고치면 된다.

3. 코드 가독성 상승

   함수는 물론, 매개변수에도 식별자를 붙일 수 있기 때문에, 식별자를 통해 함수의 역할을 파악할 수 있게 된다.

---

## 함수 리터럴

원시값, 객체와 마찬가지로 함수 또한 함수 리터럴로 생성할 수 있다. 함수 리터럴은 다음과 같이 구성된다.

- `function` 키워드
- 함수 이름

  함수 이름도 식별자이기 때문에 식별자 네이밍 규칙을 준수해야 한다.

  함수 이름은 선택 사항으로, 식별자를 가진 함수를 기명 함수, 가지지 않은 함수를 익명/무기명 함수라고 한다.

  함수 이름은 **함수 몸체 내에서만 참조할 수 있는 식별자이다.**

- 매개변수 목록

  매개 변수의 이름도 식별자이기 때문에 식별자 네이밍 규칙을 준수해야 한다.

  인수의 순서대로 매개 변수에 할당되기 때문에, 매개 변수의 순서는 의미가 있는 순서이다.

- 함수 몸체

```javascript
var f = function add(x, y) {
  return x + y;
};
```

리터럴은 값을 생성하기 위한 표기법으로, **함수 리터럴 또한 평가되어 값을 생성하며, 이 값은 객체이다.** 즉 함수는 객체이다.

---

## 함수 정의

함수를 정의하는 방법은 다음 4가지와 같다.

- 함수 **선언문**

  ```javascript
  function trainAgility(player) {
    player.agility += 1;
  }
  ```

- 함수 표현식

  ```javascript
  var trainAgility = function (player) {
    player.agility += 1;
  };
  ```

- `Function` 생성자 함수

  ```javascript
  var trainAgility = new Function('player', 'player.agility += 1');
  ```

- 화살표 함수

  ```javascript
  var trainAgility = (player) => {
    player.agility += 1;
  };
  ```

함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다. 따라서 ECMAScript 사양에서도 변수는 선언한다고 표현하지만, 함수는 정의한다고 표현한다. 실제로 변수도 선언과 동시에 `undefined` 값이 할당되어 정의되지만, ECMAScript 사양을 따르자..!

---

### 함수 선언문

함수 선언문을 이용해 함수를 정의할 때에는 함수의 식별자(이름)을 생략할 수 없다. 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다. 그런데 왜 함수 선언문을 이용하여 함수를 정의할 때 함수의 식별자를 생략할 수 없는 것일까?

먼저, 함수 표현식과 함수 선언문의 차이부터 살펴보자. 함수 선언문은 함수 식별자를 생략할 수 없다. 함수 표현식에서 함수 식별자는 선택 사항이다. 따라서, 함수 식별자를 가지고 있는 함수 표현식은 함수 선언문과 똑같이 생겼다. 따라서 자바스크립트 엔진이 함수 식별자를 가진 함수 표현식을 함수 선언문으로 해석할 가능성이 생긴다.

그래서, 자바스크립트 엔진은 식별자를 가진 함수 리터럴이 단독으로 쓰이면 함수 선언문으로 판단하고, 식별자를 가진 함수 리터럴이 피연산자로 쓰이면 함수 표현식으로 해석한다. 함수를 정의하는 방식이 비슷해보이지만, 내부 동작은 다르다. 내부 동작의 차이에 대해 알아보자.

```javascript
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() {
  console.log('foo');
}
foo(); // foo

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
// 함수 리터럴에서는 함수 이름을 생략할 수 있다.
(function bar() {
  console.log('bar');
});
bar(); // ReferenceError: bar is not defined
```

먼저 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자이기 때문에, 함수 외부에서는 함수 이름으로 함수를 호출할 수 없다. 즉, 함수를 가리키는 식별자가 없다는 뜻이다. 따라서 위의 두 코드는 함수를 어떤 식별자에 함수를 할당하지 않았기 때문에, 두 코드 모두 원래 `ReferenceError`가 나야 정상이다. 둘 모두 함수 식별자로 호출하려 시도했지만, 메모리 공간 어디에도 함수 식별자가 가리키는 공간은 없기 때문이다.

그러나, 함수 선언문으로 정의한 함수 `foo`는 함수 식별자로 호출되었다. 이는 단독으로 쓰인 기명 함수 리터럴은 함수 선언문으로 가정하고,

1. 함수 선언문을 해석하여 함수 객체를 생성한다.

2. 생성된 함수를 호출하기 위해 함수 식별자와 동일한 이름의 식별자를 암묵적으로 생성한다.

3. 생성한 식별자에 생성된 함수 객체를 할당한다.

이러한 이유로 식별자를 가진 함수 리터럴을 단독으로 사용할 때( = 함수 선언문으로 함수를 정의할 때)에 식별자를 생략할 수 없다. **중요한 것은 함수 식별자로 함수를 호출한 것으로 보이지만, 사실은 함수 객체를 가리키는 식별자로 호출한 것이다.**

반대로, 두 번째 코드는 기명 함수 리터럴이 그룹 연산자 `()`의 피연산자로 쓰여 자바스크립트 엔진이 함수 표현식으로 판단하였고, 함수 선언문과 달리 함수 식별자와 동일한 이름의 식별자를 암묵적으로 생성하지 않았기 때문에 함수 식별자로 호출하려 시도하였지만, 호출이 되지 않은 것이다.

---

### 함수 표현식

일급 객체란 값으로 사용할 수 있는 객체를 말한다. 함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이렇게 정의하는 방식을 함수 표현식이라 한다.

위에서 설명했듯이 함수 선언문과 함수 표현식은 비슷하게 동작하는 것처럼 보이지만 내부 동작이 매우 다르다..!

---

### 함수 생성 시점과 함수 호이스팅

1. 함수 선언문으로 함수 정의 -> 함수 호이스팅 발생
2. 함수 표현식으로 함수 정의 -> 변수 호이스팅 발생

이는 곧 함수 선언문으로 정의한 함수는 **런타임 이전**에 함수 리터럴이 평가되어 객체로 생성되고, 함수 식별자와 동일한 식별자를 암묵적으로 생성하여 해당 식별자에 객체까지 할당된다는 것이다(함수 호이스팅). 반대로, 함수 표현식으로 정의한 함수는 런타임 이전에 할당한 식별자만 호이스팅(변수 호이스팅)되고, 함수 리터럴은 **런타임 중**에 평가되어 객체로 생성되어 식별자에 할당된다.

함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 규칙을 무시하기 때문에, 함수 호이스팅이 일어나지 않는 함수 표현식이 권장된다.

---

### Function 생성자 함수

`Function` 생성자 함수로 함수를 생성하는 방식은 일반적이지 않고, 바람직하지 않다. 또한, 함수 선언문이나 함수 표현식으로 정의한 함수와 다르게 동작한다. 예를 들어, 클로저를 생성하지 않는 등이 있다. 아직 배우지 않았기 때문에 다르게 동작한다는 것만 인지하고 넘어간다..!

---

### 화살표 함수

화살표 함수는 항상 익명 함수로 정의하며, 기존의 함수보다 표현만 간략한 것이 아니라 내부 동작 또한 간략화되어 있어 함수 선언문, 함수 표현식을 완전히 대체하기 위한 것은 아니다. 동작이 다른데, 그 동작에 대한 것을 아직 배우지 않았기 때문에 일단 넘어간다..!

---

## 함수 호출

`식별자(인수1, 인수2, ....);`

### 매개변수와 인수

함수를 실행하기 위해 필요한 값을 함수 외부에서 함수 내부로 전달할 필요가 있는 경우, 매개변수(parameter, 인자)를 통해 인수(argument)를 전달한다.

매개변수는 함수 몸체 내부에서 변수와 동일하게 취급되기 때문에, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 `undefined`로 초기화된 이후 인수가 순서대로 할당된다.

인수의 수가 매개변수의 수보다 많다면, 에러가 일어나지 않고, 남은 매개변수들에 `undefined`가 할당된다. 반대로, 매개변수의 수가 인수의 수보다 많다면, 초과된 인수들은 무시되는 것처럼 보이지만, 모든 인수는 암묵적으로 `arguments` 객체의 프로퍼티로 보관된다. 이는 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용된다.

```javascript
function add(x, y) {
  console.log(arguments);
  // Arguments(3) [2, 5, 10, callee: ƒ, Symbol(Symbol.iterator): ƒ]

  return x + y;
}

add(2, 5, 10);
```

---

### 인수 확인

자바스크립트는 동적 타이핑 언어이기 때문에, 인수를 전달할 때, 어떤 타입의 인수를 전달해야 하는지, 함수 몸체 내부에서 특정 동작 실행 후 값을 반환할 때, 어떤 타입의 값을 반환할 지가 명확하지 않다.

이를 해결하기 위한 방법으로 다음 3가지 방법을 쓸 수 있다.

1. 타입스크립트 사용
2. 매개 변수를 사용하기 전 논리 연산자의 단축 평가로 기본값 할당

```javascript
function add(a, b, c) {
  a = a || 0;
  b = b || 0;
  c = c || 0;
  return a + b + c;
}

console.log(add(1, 2, 3)); // 6
console.log(add(1, 2)); // 3
console.log(add(1)); // 1
console.log(add()); // 0
```

3. ES6의 매개 변수 기본값 할당 방식 사용

```javascript
function add(a = 0, b = 0, c = 0) {
  return a + b + c;
}

console.log(add(1, 2, 3)); // 6
console.log(add(1, 2)); // 3
console.log(add(1)); // 1
console.log(add()); // 0
```

---

### 매개변수의 최대 개수

함수의 인수와 매개변수의 순서는 의미가 있다. 이는 곧 함수의 유지 보수성이 떨어진다는 것을 의미한다. 또한, 함수가 많은 매개변수를 사용할 수록 코드의 가독성, 유지 보수성이 떨어진다. 따라서, 최대 3개의 매개변수를 전달하는 것이 권장된다.

그러나, 만약에 3개 이상의 매개변수를 써야할 경우 객체의 프로퍼티로 지정하여 하나의 매개변수만 쓰면 위의 사항이 모두 해결된다. 매개변수의 순서를 신경쓸 필요가 없고, 유지나 보수를 할 때에도 객체만 수정하면 된다.

그러나, 객체는 얕은 복사로 인해 객체를 함수로 전달하여 함수 몸체 내에서 객체의 프로퍼티를 수정한다면, 원본 객체에도 영향이 가기 때문에 주의해야 한다.

---

### 반환문

함수 호출은 표현식이다. 함수 호출 표현식은 return 키워드가 반환한 표현식의 평가 결과, 즉 반환값으로 평가된다.

반환문의 피연산자는 자바스크립트에서 사용 가능한 모든 값이 될 수 있다. 피연산자를 생략한다면 암묵적으로 `undefined`를 반환한다.

반환문은 함수 몸체 내부에서만 사용할 수 있다. 전역에서 반환문을 사용하면 문법 에러(SyntaxError: Illegal return statement)가 발생한다.

---

### 참조에 의한 전달과 외부 상태의 변경

함수가 외부 상태(위 예제의 경우, 객체를 할당한 person 변수)를 변경하면 상태 변화를 추적하기 어려워진다. 이는 코드의 복잡성을 증가시키고 가독성을 해치는 원인이 된다. 이는 객체가 mutable 값이기 때문에 발생한다. 이를 해결하기 위한 방법은 다음 2가지와 같다.

1. 옵저버 패턴 사용
2. 불변 객체 사용

깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체하여 원본 객체를 건드릴 일이 없게 한다.

외부 상태를 변경하거나 의존하지 않는 함수를 순수 함수라고 하는데, 순수 함수를 사용하여 부수 효과와 에러를 방지하고 안정성을 높이려는 프로그래밍 패러다임을 함수형 프로그래밍이라고 한다.

---

## 다양한 함수의 형태

### 즉시 실행 함수

즉시 실행 함수는 익명 함수를 사용하는 것이 일반적이며, 정의와 동시에 즉시 호출된다. 익명 함수이든 기명 함수이든 즉시 실행 함수는 다시 호출할 수 없다. 즉시 실행 함수는 반드시 그룹 연산자로 감싸야 하며, 감싸지 않고 익명 함수일 경우 SyntaxError가 발생한다.

```javascript

function () { // SyntaxError: Function statements require a function name
  // ...
}();

```

```javascript

function foo() {
  // ...
}(); // SyntaxError: Unexpected token ')'

```

그룹 연산자로 묶지 않고 익명 함수를 쓸 경우, 자바스크립트 엔진이 함수 리터럴이 피연산자로 쓰이지 않았기 때문에 함수 선언문으로 판단하는데, 함수 선언문은 함수 식별자를 생략할 수 없기 때문이다.

그룹 연산자로 묶지 않고 기명 함수를 쓸 경우, `function foo() {};();`와 같이 세미콜론 자동 삽입 기능으로 인해 함수 선언문이 끝나는 위치인 블록문 뒤 쪽에 자동으로 세미콜론을 삽입하게 된다. 그 다음 그룹 연산자를 인식하는데, 그룹 연산자에 피연산자가 없기 때문에 `)`에서 예상치 못한 토큰이 나왔다고 에러를 발생시키는 것이다.

따라서, 다음과 같은 피연산자를 사용하여 즉시 실행 함수와 함수 선언문을 구분하여 사용한다.

```javascript
(function () {
  // ...
})();

(function () {
  // ...
})();

!(function () {
  // ...
})();

+(function () {
  // ...
})();
```

---

### 재귀 함수

재귀 함수(recursive function)는 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수이다. 재귀 함수는 반복되는 처리를 위해 사용한다.

함수 내부에서는 함수 이름을 사용해 자기 자신을 호출할 수 있다. 함수 표현식으로 정의한 함수 내부에서는 함수 이름은 물론 함수를 가리키는 식별자로도 자기 자신을 재귀 호출할 수 있다.

재귀 함수는 반복되는 처리를 반복문 없이 구현할 수 있다는 장점이 있지만 무한 반복에 빠질 위험이 있고, 이로 인해 스택 오버플로 에러를 발생시킬 수 있다. 따라서, 재귀 함수를 사용할 때 가독성이 더 좋을 때에만 한정적으로 사용하는 것이 바람직하다.

---

### 중첩 함수

함수 내부에 정의된 함수를 중첩 함수(nested function) 또는 내부 함수(inner function)라 한다. 그리고 중첩 함수를 포함하는 함수는 외부 함수(outer function)라 부른다. 일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수(helper function)의 역할을 한다.

ES6 이전에는 코드의 최상위, 다른 함수 내부에서만 정의할 수 있었으나, ES6부터는 if 문이나 for 문 등의 코드 블록 내에서도 함수를 정의할 수 있다.

내부 함수는 외부 함수의 변수를 참조할 수 있다!

```javascript
function liverpool() {
  var stadium = 'anfield';

  function buyPlayer(player) {
    console.log(`now ${player} is in ${stadium}`);
  }

  buyPlayer('hyorard');
}

liverpool();
```

---

### 콜백 함수

함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수(callback function)라고 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수(Higher-Order Function, HOF)라고 한다.

콜백 함수를 쓰는 이유는 함수의 변하지 않는 공통 로직은 미리 정의해 두고, 경우에 따라 변경되는 로직은 추상화해서 함수 외부에서 함수 내부로 전달하여 함수의 유연성을 높이기 위함이다. 여기서 경우에 따라 변경되는 로직을 외부에서 함수로 정의하여, 콜백 함수로 만드는 것이다.

중첩 함수가 외부 함수를 돕는 헬퍼 함수의 역할을 하는 것처럼 콜백 함수도 고차 함수에 전달되어 헬퍼 함수의 역할을 한다. 단, 중첩 함수는 고정되어 있어서 교체하기 곤란하지만 콜백 함수는 함수 외부에서 고차 함수 내부로 주입하기 때문에 자유롭게 교체할 수 있다는 장점이 있다. 즉, 고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.

콜백 함수가 고차 함수 내부에만 호출된다면 콜백 함수를 **익명 함수 리터럴로 정의하면서 곧바로 고차 함수에 전달**하는 것이 일반적이다.

---

### 순수 함수와 비순수 함수

함수형 프로그래밍에서는 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 순수 함수(pure function)라 하고, 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수를 비순수 함수(impure function)라고 한다.

함수 외부 변수를 직접 참조, 수정하거나, 객체를 매개변수로 받는다면, 비순수 함수 그렇지 않다면 순수 함수이다.
