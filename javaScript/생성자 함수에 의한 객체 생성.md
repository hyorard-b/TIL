# 생성자 함수에 의한 객체 생성

## Object 생성자 함수

`new` 연산자와 함께 `Object` 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 빈 객체를 생성한 이후 프로퍼티 또는 메서드를 추가하여 객체를 완성할 수 있다.

생성자 함수(constructor)란 `new` 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 인스턴스(instance)라 한다.

---

## 생성자 함수

### 객체 리터럴에 의한 객체 생성 방식의 문제점

객체 리터럴에 의한 객체 생성 방식은 단 하나의 객체만 생성한다. 따라서 동일한 프로퍼티를 갖는 객체를 **여러 개 생성해야 하는 경우** 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적이다.

또한, 동일한 프로퍼티 구조를 가지는 객체들은 메서드의 경우 같은 동작을 하는 것이 일반적이고, 객체 리터럴로 이러한 객체들을 생성할 경우 **같은 메서드를 반복해서 기술** 해야 한다.

---

### 생성자 함수에 의한 객체 생성 방식의 장점

생성자 함수는 이름 그대로 객체(인스턴스)를 생성하는 함수다. 하지만 자바와 같은 클래스 기반 객체지향 언어의 생성자(constructor)와는 다르게 그 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 `new` 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다. 만약 `new` 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다.

일반 함수 내의 `this`는 전역 객체인 `window`를 뜻하고, `new` 연산자와 함께 호출하지 않은 생성자 함수에서, 프로퍼티를 정의하려고 `this.radius = 15;` 라고 한다면, `radius`는 전역 변수가 되어버린다. `window`의 프로퍼티가 되기 때문이다.

```javascript
const Player = function (name) {
  this.name = name;
  this.myName = function () {
    return this.name;
  };
};

const hyorard = Player('hyorard');

console.log(hyorard); // 일반 함수로 return 문이 없으므로 undefined
console.log(name); // 전역 변수가 되어버림. 'hyorard'
console.log(hyorard.name); // TypeError: Cannot read property 'name' of undefined
```

---

### 생성자 함수의 인스턴스 생성 과정

자바스크립트 엔진은 인스턴스를 생성하고 난 뒤 암묵적으로 인스턴스를 반환한다. 따라서, 생성자 함수에 따로 반환을 하지 않더라도 생성한 인스턴스가 반환된다.

생성자 함수의 인스턴스 생성 과정은 다음과 같다.

1. 인스턴스 생성

   - 암묵적으로 빈 객체를 생성한다.
   - 빈 객체를 `this`와 바인딩한다.

   필수적인 과정으로, 생성자 함수 몸체의 코드 런타임 이전에 실행된다.

2. 인스턴스 초기화

   - `this`에 바인딩되어 있는 인스턴스의 프로퍼티를 생성하고 초기화한다.

   선택 과정으로, 런타임에 프로퍼티를 생성 및 초기화한다.

3. 인스턴스 반환

   - 생성자 함수 몸체의 코드의 처리가 모두 끝나면 인스턴스가 바인딩된 `this`를 암묵적으로 반환한다.

   함수 내부에서 명시적으로 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손하는 것이므로 지양해야 하며, 만약 다른 객체를 반환할 경우, 해당 다른 객체가 반환되지만, 원시값을 반환할 경우 무시하고 `this`가 반환된다.

---

### 내부 메서드 `[[Call]]`과 `[[Construct]]`

함수는 객체이지만 일반 객체와는 다르다. 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다. 따라서 함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드는 물론, 함수로서 동작하기 위해 함수 객체만을 위한 `[[Environment]]`, `[[FormalParameters]]` 등의 내부 슬롯과 `[[Call]]`, `[[Construct]]` 같은 내부 메서드를 추가로 가지고 있다.

함수가 일반 함수로서 호출되면 함수 객체의 내부 메서드 `[[Call]]`이 호출되고 `new `연산자와 함께 생성자 함수로서 호출되면 내부 메서드 `[[Construct]]`가 호출된다.

함수 객체는 반드시 callable이어야 한다. 따라서 모든 함수 객체는 내부 메서드 `[[Call]]`을 갖고 있으므로 호출할 수 있다. 하지만 모든 함수 객체가 `[[Construct]]`를 갖는 것은 아니다. 다시 말해, 함수 객체는 constructor일 수도 있고 non-constructor일 수도 있다.

---

### constructor와 non-constructor의 구분

21. non-constructor인 함수

    ES6의 화살표 함수와 메서드 축약 표현으로 정의된 함수가 non-constructor이며, 즉 메서드를 의미한다. 객체의 프로퍼티가 함수이면 메서드라고 하지만, ECMAScript에서는 ES6의 메서드 축약 표현만을 의미하기 때문에, 함수가 객체 내에 있다고 해서 모두 메서드인 것이 아니라, 함수 정의 방식에 따라 메서드를 구분하게 되고 즉, `[[Construct]]` 내부 메서드를 가지는지 가지지 않는지가 결정된다.

    ```javascript
    const player = {
      myName: function () {
        console.log('my name');
      },
      myBackNumber() {
        console.log('8');
      },
    };

    new player.myName(); // [[Construct]] 내부 메서드가 에러를 일으키지 않음
    new player.myBackNumber(); // TypeError: player.myBackNumber is not a constructor

    const ball = () => {};

    new ball(); // TypeError: ball is not a constructor
    ```

22. constructor인 함수

    `[[Call]]`, `[[Construct]]` 두 내부 메서드 모두 가지고 있는 함수로 함수 선언문, 함수 표현식, 객체의 프로퍼티로 할당되어 일반 함수로 정의된 함수가 이에 해당된다.

주의할 것은 생성자 함수로서 호출될 것을 기대하고 정의하지 않은 일반 함수(callable이면서 constructor)에 `new` 연산자를 붙여 호출하면 생성자 함수처럼 동작할 수 있다는 것이다.

---

### new 연산자

생성자 함수로서 정의하지 않은 함수를 `new` 연산자와 함께 호출하여 생성자 함수로서 기능하게 한다면 어떻게 될까?

```javascript
function stepOver(time) {
  const direction = time % 2 ? 'right' : 'left';
  return `faked defender and head to ${direction}`;
}

let nextMove = new stepOver(); // 원시값 반환했으므로 무시 후 빈 객체 생성되어 반환
// stepOver {}

function StepOver(time) {
  const direction = time % 2 ? 'right' : 'left';
  return { move: `faked defender and head to ${direction}` };
}

nextMove = new StepOver(2);
console.log(nextMove);
```

---

### new.target

생성자 함수가 `new` 연산자 없이 호출되는 것을 방지하기 위해 파스칼 케이스 컨벤션을 사용한다 하더라도 실수는 언제나 발생할 수 있다. 이러한 위험성을 회피하기 위해 ES6에서는 `new.target`을 지원한다.

`new.target`은 `this`와 유사하게 constructor인 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용되며 메타 프로퍼티라고 부른다. IE는 `new.target`을 지원하지 않으므로 주의하여야 한다.

```javascript
function StepOver(time) {
  // ES6의 new.target
  if (!new.target) {
    return new StepOver(time);
  }

  // 스코프 세이프 생성자 패턴
  if (!(this instanceof StepOver)) {
    return new StepOver(time);
  }

  const direction = time % 2 ? 'right' : 'left';
  return { move: `faked defender and head to ${direction}` };
}
```

`new` 연산자와 함께 호출된 함수에 의해 생성된 객체는 프로토타입에 의해 생성자 함수와 연결된다. 이를 이용해 `new` 연산자와 함께 호출되었는지 확인할 수 있다.

`Object`와 `Function` 생성자 함수는 `new` 연산자 없이 호출해도 `new` 연산자와 함께 호출했을 때와 동일하게 동작한다.

하지만 `String`, `Number`, `Boolean` 생성자 함수는 `new` 연산자와 함께 호출했을 때 `String`, `Number`, `Boolean` 객체를 생성하여 반환하지만 `new` 연산자 없이 호출하면 문자열, 숫자, 불리언 값을 반환한다. 이를 통해 데이터 타입을 변환하기도 한다.
