# 제어문

제어문은 일반적으로 위에서 아래 방향으로 순차적으로 실행되는 흐름을 인위적으로 제어할 수 있다.

- 장점

  코드의 실행 흐름을 개발자 의도대로 제어할 수 있다.

- 단점

  코드의 흐름을 이해하기 어렵게 만들어 가독성을 해치고 이는 곧 오류를 발생시키는 원인이 된다.

- 해결 방법

  `forEach`, `map`, `filter`, `reduce` 같은 고차 함수를 사용한 함수형 프로그래밍 기법으로 제어문 사용을 억제하여 복잡성을 해결할 수 있다.

---

## 블록문

블록문은 0개 이상의 문을 중괄호로 묶은 것으로, 단독으로 사용할 수 있으나 일반적으로 제어문이나 반복문, 함수를 정의할 때 사용한다.

문의 끝에는 모두 세미콜론을 붙이지만, 블록문은 자체 종결성을 가지기 때문에 블록문의 끝에는 세미콜론을 붙이지 않는다.

---

## 조건문

조건식은 불리언 값으로 평가될 수 있는 표현식이다. 조건문은 조건식의 평가 결과에 따라 코드 블록의 실행을 결정한다.

조건문은 두 가지로 구분할 수 있다.

- `if...else`문
- `switch`문

---

### if...else 문

```javascript
if (조건식) {
  // do something
} else if (조건식) {
  // do something
} else {
  // do something
}
```

`if...else` 문은 조건식이 `true`일 경우, `if` 의 코드 블록이 실행된다.
반대로, 조건식이 `false`일 경우, `else`문의 코드 블록이 실행된다.

조건식이 불리언 값으로 평가되지 않을 경우, 자바스크립트 엔진이 조건식을 강제로 불리언 값으로 변환시켜 실행할 코드 블록을 결정한다.

만약 코드 블록 내의 문이 하나뿐이라면 중괄호를 생략할 수 있다. 그러나, 이 경우에는 삼항 조건 연산자를 사용하여 코드 가독성을 높이도록 한다..!

그렇다면 `if...else` 문을 변수에 할당할 수 있을까?

삼항 조건 연산자는 값으로 평가되는 표현식을 만든다. 따라서 삼항 조건 연산자 표현식은 값처럼 사용할 수 있기 때문에 변수에 할당할 수 있다. 하지만 if…else 문은 표현식이 아닌 문이다. 따라서 if…else 문은 값처럼 사용할 수 없기 때문에 변수에 할당할 수 없다.

---

### switch 문

`switch` 문의 표현식과 일치하는 case 문이 없다면 실행 순서는 `default` 문으로 이동한다. `default` 문은 선택 사항이다.

삼항 조건 연산자는 값으로 평가되는 표현식을 만든다. 따라서 삼항 조건 연산자 표현식은 값처럼 사용할 수 있기 때문에 변수에 할당할 수 있다. 하지만 if…else 문은 표현식이 아닌 문이다. 따라서 if…else 문은 값처럼 사용할 수 없기 때문에 변수에 할당할 수 없다.

```javascript
var player = 'hyorard',
  reputation;

switch (player) {
  case 'gerrard':
    reputation = 'liverpool legend';
    break;
  case 'hyorard':
    reputation = 'post gerrard';
  case 'mane':
    reputation = 'world class';
    break;
  default:
    reputation = 'unknown';
}

print(reputation); // world class not post gerrard..
```

`break` 문을 사용하지 않아 폴스루가 발생하는 경우이다. `player`가 'hyorard'의 값을 가지고 있으면, `reputation`에 'post gerrard'를 할당하려고 했으나, `break`문을 사용하지 않았고, 폴스루가 발생하여 `case 'mane'`문이 실행되어 `reputation`에 'world class'가 할당되었다. 만약 `case 'mane'`문에 `break` 문을 사용하지 않았다면 `default` 문도 예외 없이 실행시키게 된다. 그리고 마지막에 위치하였기 때문에, `default` 문이 종료되면 `switch` 문을 빠져나가게 된다.

상황에 따라 가독성을 판단하고, `if...else`문과 `switch`문을 적절하게 선택하여 사용하자..!

---

## 반복문

반복문은 세 가지로 구분할 수 있다.

- `for` 문
- `while` 문
- `do...while` 문

---

### for 문

```javascript

for (선언문 및 할당문; 조건식; 증감식) {
    // do something
}

// 무한 루프

for (;;) {
    // do something infinitely
}

```

### while 문

```javascript
var team = 'MU';
var year = 0;

while (team === 'MU') {
  // can't win
  year++;

  if (year >= 4) {
    team = 'other team';
  }
} // can win..

// infinite loop
mbappeAge = 18;
while ('PSG') {
  mbappeAge++;
  console.log(`Mbappe(${mbappeAge}), PSG`); // can't escape..
}
```

---

### do...while 문

```javascript
var mourinhoYear = 1;

do {
  // very good
} while (mourinhoYear < 3);
{
  // the mourinho's second season
}

// mourinho out..
```

---

## break 문

레이블 문은 식별자가 붙은 문이다.

```javascript
bale: {
  console.log('glass');
  break bale;
  console.log('top agility');
}
```

레이블 문, 반복문, switch 문의 코드 블록 외에 break 문을 사용하면 SyntaxError(문법 에러)가 발생한다.

---

## continue 문

continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.

---

# 타입 변환과 단축 평가

- 명시적 타입 변환, 타입 캐스팅

  개발자가 의도적으로 값의 타입을 변경하는 것이다.

- 암묵적 타입 변환, 타입 강제 변환

  개발자의 의도와 상관 없이 자바스크립트 엔진이 타입을 변경하는 것이다.

암묵적 타입 변환은 기존 변수 값을 재할당하여 변경하는 것이 아니다. 자바스크립트 엔진은 표현식을 에러 없이 평가하기 위해 피연산자의 값을 암묵적 타입 변환해 **새로운 타입의 값을 만들어 단 한 번 사용하고 버린다**.

그러나, 암묵적 타입 변환은 개발자의 의지가 코드에 명백히 나타나지 않아 이에 따른 결과값을 예측하기 어려워 오류를 생산할 가능성이 높아진다.

그렇다고 암묵적 타입 변환을 사용하지 않는다면, 암묵적 타입 변환을 사용할 때 가독성이 좋은 경우에 맞지 않다.

결론 - 공부 빡세게 해서 예측을 잘하면 된다.

---

## 암묵적 타입 변환

### string 으로의 암묵적 타입 변환

```javascript

// 숫자 타입
0 + ''         // -> "0"
-0 + ''        // -> "0"
1 + ''         // -> "1"
-1 + ''        // -> "-1"
NaN + ''       // -> "NaN"
Infinity + ''  // -> "Infinity"
-Infinity + '' // -> "-Infinity"

// 불리언 타입
true + ''  // -> "true"
false + '' // -> "false"

// null 타입
null + '' // -> "null"

// undefined 타입
undefined + '' // -> "undefined"

// 심벌 타입
(Symbol()) + '' // -> TypeError: Cannot convert a Symbol value to a string

// 객체 타입
({}) + ''           // -> "[object Object]"
Math + ''           // -> "[object Math]"
[] + ''             // -> ""
[10, 20] + ''       // -> "10,20"
(function(){}) + '' // -> "function(){}"
Array + ''          // -> "function Array() { [native code] }"

```

---

### 숫자 타입으로 변환

```javascript
// 문자열 타입
+'' + // -> 0
  '0' + // -> 0
  '1' + // -> 1
  'string' + // -> NaN
  'true' + // -> NaN
  'false' + // -> NaN
  // 불리언 타입
  true + // -> 1
  false + // -> 0
  // null 타입
  null + // -> 0
  // undefined 타입
  undefined + // -> NaN
  // 심벌 타입
  Symbol() + // -> ypeError: Cannot convert a Symbol value to a number
  // 객체 타입
  {} + // -> NaN
  [] + // -> 0
  [10, 20] + // -> NaN
  function () {}; // -> NaN
```

---

### 불리언 타입으로 변환

`if`, `for`, 삼항 조건 연산자의 조건식들은 조건식의 평가 결과를 `boolean` 타입으로 암묵적 타입 변환한다.

이 때, 자바스크립트 엔진은 `boolean` 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다.

- Truthy 값

  Falsy 값 외의 모든 값

- Falsy 값

  - false
  - undefined
  - null
  - 0, -0
  - ''
  - NaN

```javascript
if ('0') console.log('truthy');
if ([]) console.log('truthy');
if ({}) console.log('truthy');
```

---

## 명시적 타입 변환

### 문자열 타입으로 변환

- `String` 생성자 함수를 `new` 연산자 없이 호출
- `.toString()` 메서드 사용
- 문자열 연결 연산자 사용

---

### 숫자 타입으로 변환

- `Number` 생성자 함수를 `new` 연산자 없이 호출
- `parseInt()`, `parseFloat()` 함수 사용
- - 단항 산술 연산자 이용
- - 산술 연산자 이용 `something * 1`

---

### 불리언 타입으로 변환

- `Boolean` 생성자 함수를 `new` 연산자 없이 호출
- `!` 부정 논리 연산자를 두 번 사용

---

## 단축 평가

### 논리 연산자를 사용한 단축 평가

논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다. 이를 단축 평가(short-circuit evaluation)라 한다. 단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.

```javascript
'Cat' && 'Dog'; // -> "Dog"
'Cat' || 'Dog'; // -> "Cat"

var done = true;
var message = '';
message = done && '완료';
console.log(message); // 완료

done = false;
message = done || '미완료';
console.log(message); // 미완료
```

---

### 옵셔널 체이닝 연산자

`?.` 연산자는 좌항의 피연산자가 `null`, `undefined`인 경우 `undefined`를 반환하고 그렇지 않은 경우 우항을 그대로 반환한다.

---

### null 병합 연산자

`??` 연산자는 좌항의 피연산자가 `null`, `undefined`인 경우 우항을 반환하고 그렇지 않은 경우 좌항의 피연산자를 그대로 반환한다.

---

# ASCII 코드와 유니코드

## 1바이트가 8비트인 이유와 ASCII 코드

컴퓨터 아키텍쳐가 영문권인 곳에서 발전했기 때문이라고 한다.
0101010 로 이루어진 전자신호를 사람이 인식할 수 있는 문자로 저장을 했어야 했는데, 이런 문자를 표현하는 코드들의 숫자가 7bit ~8bit 으로 충분했기 때문이라고 한다.

(ASCII : 제어문자(32개), 출력가능문자(영소문자, 영대문자, 숫자, 기타 기호, parity bit 등등)

현재도 ASCII extended 부호를 사용하고 있다. (7bit + 1bit)

이래서 1Byte에 문자 1개를 저장할 수 있는 8bit 구조가 된 것이라고 한다.

---

## 유니코드

7비트에서 8비트로 늘린 ASNI 코드에서도 비유럽 국가의 문자를 표현하기에는 여전히 제한적이다. 이를 보완하기 위해 전 세계 언어의 문자를 정의하기 위한 국제 표준 코드가 등장하였는데 이것이 유니코드이다.

유니코드는 2바이트로 표현되고, 총 17개 구역이 존재한다. 110여만 자의 모든 문자를 2바이트 즉 (2^16)로 나눈 것이 대략 16.78개로 17로서 나눈 것이다.
