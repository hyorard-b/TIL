# 변수

## 변수란?

직접적인 메모리 주소를 통해 값에 직접 접근하는 것은 치명적인 오류를 발생시킬 수 있다. 따라서 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다. 따라서, 기억하고 싶은 값을 메모리에 저장하거나 읽어들이기 위해 변수라는 매커니즘을 제공한다.

변수 두 가지 의미를 가진다.

1. 값을 저장하기 위한 메모리 공간 자체
2. 값을 저장한 메모리 공간을 식별하기 위해 붙인 이름

즉, 값의 위치를 가리키는 상징적인 이름이다.

---

## 할당과 참조

변수에 값을 저장하는 것을 할당, 저장한 값을 읽어 들이는 것을 참조라고 한다.

---

## 식별자

식별자란 변수의 이름을 뜻하며, 실제로 변수 이름을 값으로 가지고 있는 게 아닌 변수의 메모리 주소를 가지고 있다. 즉, 메모리 상에 존재하는 어떤 값, 예를 들어 변수, 함수, 클래스 등을 식별할 수 있는 이름을 모두 식별자라고 부른다.

선언으로 자바스크립트 엔진에 식별자의 존재를 알린다. 그렇다면 선언은 무엇일까?

---

## 선언

변수를 선언했다는 것은 다음과 같은 과정을 모두 완료했다는 것이다.

1. 값을 저장하기 위한 메모리 공간을 확보한다.
2. 메모리 공간의 주소를 식별자와 연결한다.

선언을 하고 변수 값을 초기화하지 않았다면, **호이스팅**에 의해 해당 변수 선언문은 유효 범위의 맨 위로 올라가고 `undefined` 값이 할당된다. 이는 런타임 시가 아닌 그 전 단계인 소스코드의 평가 과정에서 실행된다.

이에 따르면, 결국 초기화는 변수에 초기값을 주는 것이 아닌, `undefined`였던 값을 재할당하는 것이 된다.

여기서 주의해야 할 것은 `undefined`가 있던 공간에 `undefined` 값을 지우고 재할당한 다음 식별자가 그곳을 계속 가리키는 것이 아니라, **초기화 하는 순간 식별자는 다른 공간의 메모리 주소를 참조하고 해당 공간에 새 값을 할당하는 것이다.**

```javscript

console.log(score); // undefined

var score = 90;  // ① 변수 선언 및 초기화
score = 80; // ② 값의 할당

console.log(score); // 80

```

![reassign variable](./asset/reassign.JPG)

---

## 언매니지드 언어

개발자가 명시적으로 메모리를 할당하고 해제할 수 있다. 따라서, 개발자의 역량에 따라 메모리를 효율적으로 관리할 수 있으나, 반대의 경우 치명적인 오류를 유발할 수 있다.

---

## 매니지드 언어

개발자가 아닌 언어 자체가 메모리의 관리를 맡는다. 따라서, 개발자가 메모리에 대해 신경을 쓰지 않아도 되기 때문에 어느 정도 생산성을 확보할 수 있지만, 매니지드 언어에 비해 메모리를 효율적으로 관리할 수 없다.

매니지드 언어의 경우 쓰지 않는 메모리 공간의 해제를 가비지 콜렉터(GC)가 담당하는데, GC가 언제 필요하지 않은 메모리 공간을 해제할 지 예측할 수 없다는 단점도 있다.

---

## 가비지 콜렉터

GC라고 불리는 가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용하지 않는다고 판단되면, 해당 메모리 공간을 해제하여 메모리 누수를 방지한다.

---

## 변수 네이밍 규칙

1. 카멜 케이스를 사용한다.
2. `_`와 `$` 또는 알파벳으로 시작하여야 한다.
3. `_`와 `$`를 제외한 특수 문자는 사용할 수 없다.
4. 예약어는 식별자로 사용할 수 없다.

---

## 함수 네이밍 규칙

보통 파스칼 케이스를 사용한다.

변수와 네이밍 규칙은 일관성을 유지한다면 어느 컨벤션을 사용하여도 상관 없지만,
ECMAscript 사양에는 변수는 카멜 케이스, 함수는 파스칼 케이스를 사용하고 있다.

---

# 표현식과 문

## 리터럴

리터럴이란 사람이 이해할 수 있는 문자 또는 약속된 기호를 통해 **값**을 생성하는 표기 방식을 말한다.

리터럴에는 여러가지가 있다. 약속된 숫자, 문자, 기호 등을 입력하면 이것들이 모두 엔진이 이해할 수 있는 값으로 변화되는 것이다.

그렇다면 값은 무엇일까 ?

---

## 값

값은 표현식이 평가되어 생성된 결과를 말한다. 평가는 값 생성 또는 참조 모두 포함한다.

---

## 표현식

표현식은 값으로 평가될 수 있는 문이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조하는 것이다. 따라서, 리터럴도 값이기 때문에 표현식이 될 수 있다. 어떠한 값으로 표현될 수 있으면 모두 표현식이 될 수 있는 것이다.

식별자 참조 또한 값이 될 수 있다. 변수에 값을 할당했든, 선언만 하였든 `undefined` 또는 할당한 값 또는 쓰레기 값 등이 들어있으나 모두 값이기 때문에 표현식이라 할 수 있다.

---

## 토큰

더 이상 나눌 수 없는 문법적 의미를 가진 코드의 기본 요소를 의미한다.

---

## 문

명령문과 같으며, 컴퓨터에 내리는 명령이다. 문은 다수의 토큰으로 이루어져 있다.

- 선언문
- 조건문
- 할당문
- 반복문

등의 종류가 있다.

---

## 세미콜론과 세미콜론 자동 삽입 기능

세미콜론은 문의 종료를 나타낸다. 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 하나씩 문을 실행한다. 그러나, 필수는 아니다. `{}`로 묶은 코드 블록은 자체 종결성을 가지며, `{}`를 쓰지 않아 코드 블록으로 묶이지 않은 문들도 자바스크립트 엔진이 자동으로 문의 끝이라고 예측되는 지점에 세미콜론을 붙여주기 때문이다. 이를 세미콜론 자동 삽입 기능(ASI)라고 한다.

하지만, ASI의 기능과 개발자의 의도가 정확히 일치하지 않는 경우가 많기 때문에, TC39(ECMAscript 기술 위원회)도 세미콜론 사용을 권장하고 있다.

---

## 표현식인 문과 표현식이 아닌 문

문에는 두 가지 종류가 있다.

1. 표현식인 문
2. 표현식이 아닌 문

**표현식인 문**은 값으로 평가될 수 있기 때문에 표현식인 동시에 문인 것이고, **표현식이 아닌 문**은 값으로 평가될 수 없는 선언문과 같은 표현식이 아닌 문인 것이다.

한편, 할당은 값을 변수에 넣는 것이다. 따라서 **표현식인 문**은 값으로 평가될 수 있기 때문에 **표현식인 문**으로 할당을 할 수 있게 된다. 반대로 **표현식이 아닌 문**으로는 할당을 할 수 없다.

---

## 완료 값

일단 구분을 해야 한다.

```javascript
num = 100; // 할당문

var num = 100; // 할당문이 아니라 선언문..!
```

자 이제 완료값이 무엇인지 알아보자. 완료값은 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 `undefined`를 출력한다. 이를 완료값이라 하는데 완료값은 표현식의 평가 결과가 아니기 때문에 다른 값과 같이 변수에 할당할 수 없고, 참조할 수도 없다.

```javascript
var foo = 10; // undefined

foo = 10; // 10

100 + foo; // 110
```

---

# 데이터 타입

## ES6의 데이터 타입

- 원시 타입
  - 숫자(number) 타입
  - 문자열(string) 타입
  - 불리언(boolean) 타입
  - undefined 타입
  - null 타입
  - 심벌(symbol) 타입 : ES6에서 추가된 7번째 타입
- 객체 타입
  - object/reference 타입 : 객체, 함수, 배열 등

---

## number 타입

ECMAScript에서는 `number` 타입은 64비트 부동소수점 형식을 따른다. 정수, 실수, 2진수, 8진수, 16진수 리터럴 중 어느 것이든 모두 메모리에 64비트 부동소수점 형식의 2진수(**정확한 2진수가 아님**)로 저장된다.

한편, 자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 이 값을 할당은 할 수 있으나, 할당한 값을 참조하면 모두 10진수로 해석된다.

```javascript
var binary = 0b01000001; // 2진수
var octal = 0o101; // 8진수
var hex = 0x41; // 16진수

// 표기법만 다를 뿐 모두 같은 값이다.
console.log(binary); // 65
console.log(octal); // 65
console.log(hex); // 65
console.log(binary === octal); // true
console.log(octal === hex); // true
```

중요한 것은 **자바스크립트의 `number` 타입은 모든 수를 실수로 처리하기 때문에, 정수로 표시되어도 사실은 실수라는 것을 의미한다는 것이다.** 따라서, 정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있다.

추가적으로 세 가지 특별한 값들도 표현할 수 있다.

- Infinity : 양의 무한대
- -Infinity : 음의 무한대
- NaN : 산술 연산 불가

---

## string 타입

다른 타입의 값과 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자 같은 토큰과 구분하기 위해서이다.

자바스크립트의 문자열은 원시 타입이며, 변경 불가능한 값(immutable value)이다. 이것은 문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미한다.

---

## 템플릿 리터럴

ES6부터 새로 도입된 문자열 표기법이다. 여러 편리한 문자열 처리 기능을 제공하며, 런타임에 일반 문자열로 변환되어 처리 된다.

일반적인 따옴표 대신 백틱을 사용해 표현한다.

---

### 멀티라인 문자열

일반적인 문자열 내에서는 엔터키로 개행이 불가능하고, `\n`과 같은 이스케이프 시퀀스를 사용해야 한다. 그러나, 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 혀용되며, 모든 공백도 있는 그대로 적용된다.

---

### 표현식 삽입

문자열은 보통 문자열 연산자인 `+`를 사용해 연결한다. 그러나, 템플릿 리터럴 내에서는 표현식 삽입을 통해 간단히 문자열을 삽입할 수 있다.

```javascript
var anfield = 'gerrard';
var hufs = 'hyorard';

console.log(`${hufs} is post${anfield} ^_^`);
```

---

## 불리언 타입

논리적 참, 거짓을 나타내고 각각 `true`, `false` 값을 가진다.

---

## undefined 타입

undefined 타입의 값은 `undefined`가 유일하다. `var` 키워드로 선언한 변수는 암묵적으로 `undefined`로 초기화된다. 초기화하기 전에 확보한 메모리 공간에는 보통 쓰레기 값이 들어가 있는데, 자바스크립트 엔진은 이를 내버려두지 않고 `undefined`로 초기화한다.

자바스크립트는 선언과 정의의 구분이 모호하다. C는 선언을 할 때에는 메모리 공간을 확보하지 않고, 정의할 때 메모리 공간을 확보하고 주소를 식별자와 연결하기 때문에 구분이 확실하지만, 자바스크립트는 앞에서 봤듯이 그렇지 않다. ECMAScript는 변수에는 '선언한다'라고 표현하고, 함수는 '정의한다'라고 표현한다.

## null 타입

변수에 값이 없다는 것을 의도적으로 명시할 때에 사용한다. 이 의도는 변수가 이전에 참조하던 값을 더 이상 참조하지 않으니, GC를 하라고 명시하는 것이다..!

함수가 유효한 값을 반환할 수 없는 경우 명시적으로 `null`을 반환하기도 한다.
(이는 변수 선언문을 실행하였을 때 나오는 `undefined`와 헷갈릴 수도 있다 생각했음 구분해야함)

## symbol 타입

ES6에서 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값이다. `symbol` 값은 다른 값과 중복되지 않는 유일무이한 값이다. 따라서 충돌할 위험이 없도록 **객체의 유일한 프로퍼티 키**를 만들기 위해 사용한다.

`symbol` 이외의 원시 타입들은 리터럴을 사용해 생성하지만, `symbol`은 `Symbol()`함수를 호출해 생성한다.

```javascript
// 심벌 값 생성
var key = Symbol('key');
console.log(typeof key); // symbol

// 객체 생성
var obj = {};

// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
obj[key] = 'value';
console.log(obj[key]); // value
```

---

## 객체 타입

아싸

---

## 테이터 타입의 필요성

### 데이터 타입에 의한 메모리 공간의 확보와 참조

ECMAScript는 데이터 타입에 따라 확보되는 메모리 공간을 명시적으로 규정하고 있지 않다. 단, ECMAScript에 숫자 타입은 배정밀도 64비트 부동소수점 형식을 사용한다고 명시되어 있고, 64비트 부동소수점 형식은 8바이트이기 때문에, `number` 타입의 메모리 공간 크기를 8바이트로 일단 한다..!

어떤 변수를 참조할 때, 이 변수에 들어있는 값을 훼손되지 않도록 온전히 참조하려면 이 변수가 어디까지 메모리 공간을 가지고 있는지 알아야 한다. 근데 그걸 변수의 타입으로 메모리 공간의 크기를 계산해 다 들고 오는 것임! 근데 그 변수의 타입은 어떻게 아냐 이말이지;;

그리고 참조한 후에 들고온 바이트코드(?)를 어떻게 해석할 지도 그 타입으로 한다 이말이야 근데 그 타입을 어떻게 아냐 이말이야

---

## 동적 타이핑

### 동적 타입 언어와 정적 타입 언어

자바스크립트는 정적 타입 언어와는 다르게 변수를 선언할 때 타입을 선언하지 않는다. 다만 var, let, const 키워드를 사용해 변수를 선언할 뿐이다. 자바스크립트의 변수는 정적 타입 언어와 같이 미리 선언한 데이터 타입의 값만 할당할 수 있는 것이 아니다. 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다.

typeof 연산자로 변수를 연산하면 변수의 데이터 타입을 반환한다. 정확히 말하면 변수의 데이터 타입을 반환하는 것이 아니라 변수에 할당된 값의 데이터 타입을 반환한 것이다.

자바스크립트 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론. type inference)된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 이러한 특징을 동적 타이핑(dynamic typing)이라 하며, 자바스크립트를 정적 타입 언어와 구별하기 위해 동적 타입(dynamic/weak type) 언어라 한다.

### 동적 타입 언어와 변수

자바스크립트는 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다. 즉, 숫자 타입의 변수일 것이라고 예측했지만 사실은 문자열 타입의 변수일 수도 있다는 말이다. 잘못된 예측에 의해 작성된 프로그램은 당연히 오류를 뿜어낼 것이다. 결국 동적 타입 언어는 유연성(flexibility)은 높지만 신뢰성(reliability)은 떨어진다.

이러한 이유로 안정적인 프로그램을 만들기 위해 변수를 사용하기 이전에 데이터 타입을 체크해야 하는 경우가 있는데 이는 매우 번거로울뿐더러 코드의 양도 증가한다.
